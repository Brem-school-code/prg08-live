{"version":3,"sources":["App.js","libraries/decisiontree.js","reportWebVitals.js","index.js"],"names":["decisionTree","DecisionTree","config","this","predicates","a","b","root","buildDecisionTree","trainingSet","ignoredAttributes","arrayToHashSet","categoryAttr","minItemsCount","entropyThrehold","maxTreeDepth","item","predictDecisionTree","array","hashSet","i","items","attr","counter","length","mostFrequentValue","countUniqueValues","mostFrequentCount","value","p","entropy","Math","log","category","initialEntropy","alreadyChecked","bestSplit","gain","pivot","predicateName","attrPredPivot","predicate","currSplit","split","matchEntropy","match","notMatchEntropy","notMatch","newEntropy","currGain","attribute","matchSubTree","notMatchSubTree","matchedCount","notMatchedCount","tree","push","treeToJson","name","children","App","useState","Vak","setVak","Klassen","setKlassen","Docent","setDocent","startDateTime","setStartDateTime","endDateTime","setEndDateTime","signedIn","setSignedIn","upload","setUpload","resultaat","setResultaat","ignored","id","className","onSubmit","e","preventDefault","lokaal","lokaalPrediction","predict","htmlFor","type","onChange","target","accept","files","Papa","parse","download","header","dynamicTyping","complete","results","data","sort","random","trainData","slice","floor","trainModel","clientId","buttonText","onSuccess","response","onFailure","error","console","cookiePolicy","responseType","accessType","scope","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"0JAOIA,E,sFCHUC,EAAb,WACG,WAAYC,GAAS,oBACjBC,KAAKC,WAAa,CACd,KAAM,SAAUC,EAAGC,GAAK,OAAOD,GAAKC,GACpC,KAAM,SAAUD,EAAGC,GAAK,OAAOD,GAAKC,IAExCH,KAAKI,KAAOJ,KAAKK,kBAAkB,CAC/BC,YAAaP,EAAOO,YACpBC,kBAAmBP,KAAKQ,eAAeT,EAAOQ,mBAC9CE,aAAcV,EAAOU,cAAgB,WACrCC,cAAeX,EAAOW,eAAiB,EACvCC,gBAAiBZ,EAAOY,iBAAmB,IAC3CC,aAAcb,EAAOa,cAAgB,KAZhD,2CAiBG,SAAQC,GACJ,OAAOb,KAAKc,oBAAoBd,KAAKI,KAAMS,KAlBlD,4BAyBG,SAAeE,GACX,IAAIC,EAAU,GACd,GAAID,EACA,IAAK,IAAIE,KAAKF,EAAO,CAEjBC,EADWD,EAAME,KACD,EAGxB,OAAOD,IAjCd,+BAyCG,SAAkBE,EAAOC,GAGrB,IAFA,IAAIC,EAAU,GAELH,EAAIC,EAAMG,OAAS,EAAGJ,GAAK,EAAGA,IAEnCG,EAAQF,EAAMD,GAAGE,IAAS,EAG9B,IAAK,IAAIF,EAAIC,EAAMG,OAAS,EAAGJ,GAAK,EAAGA,IACnCG,EAAQF,EAAMD,GAAGE,KAAU,EAE/B,OAAOC,IApDd,+BA4DG,SAAkBF,EAAOC,GAErB,IAGIG,EAHAF,EAAUpB,KAAKuB,kBAAkBL,EAAOC,GAExCK,EAAoB,EAGxB,IAAK,IAAIC,KAASL,EACVA,EAAQK,GAASD,IACjBA,EAAoBJ,EAAQK,GAC5BH,EAAoBG,GAI5B,OAAOH,IA1Ed,qBAkFG,SAAQJ,EAAOC,GAEX,IAGIO,EAHAN,EAAUpB,KAAKuB,kBAAkBL,EAAOC,GAExCQ,EAAU,EAEd,IAAK,IAAIV,KAAKG,EAEVO,KADAD,EAAIN,EAAQH,GAAKC,EAAMG,QACPO,KAAKC,IAAIH,GAG7B,OAAOC,IA7Fd,+BAoGG,SAAkB5B,GAEd,IAAIO,EAAcP,EAAOO,YACrBI,EAAgBX,EAAOW,cACvBD,EAAeV,EAAOU,aACtBE,EAAkBZ,EAAOY,gBACzBC,EAAeb,EAAOa,aACtBL,EAAoBR,EAAOQ,kBAE/B,GAAqB,GAAhBK,GAAuBN,EAAYe,QAAUX,EAE9C,MAAO,CACHoB,SAAU9B,KAAKsB,kBAAkBhB,EAAaG,IAItD,IAAIsB,EAAiB/B,KAAK2B,QAAQrB,EAAaG,GAE/C,GAAIsB,GAAkBpB,EAIlB,MAAO,CACHmB,SAAU9B,KAAKsB,kBAAkBhB,EAAaG,IAYtD,IANA,IAAIuB,EAAiB,GAIjBC,EAAY,CAAEC,KAAM,GAEfjB,EAAIX,EAAYe,OAAS,EAAGJ,GAAK,EAAGA,IAAK,CAC9C,IAAIJ,EAAOP,EAAYW,GAGvB,IAAK,IAAIE,KAAQN,EACb,GAAKM,GAAQV,IAAiBF,EAAkBY,GAAhD,CAKA,IAAIgB,EAAQtB,EAAKM,GAIbiB,OAAa,EASbC,EAAgBlB,GAPhBiB,EADgB,iBAATD,EACS,KAIA,MAGuBA,EAC3C,IAAIH,EAAeK,GAAnB,CAKAL,EAAeK,IAAiB,EAEhC,IAAIC,EAAYtC,KAAKC,WAAWmC,GAG5BG,EAAYvC,KAAKwC,MAAMlC,EAAaa,EAAMmB,EAAWH,GAGrDM,EAAezC,KAAK2B,QAAQY,EAAUG,MAAOjC,GAC7CkC,EAAkB3C,KAAK2B,QAAQY,EAAUK,SAAUnC,GAGnDoC,EAAa,EACjBA,GAAcJ,EAAeF,EAAUG,MAAMrB,OAC7CwB,GAAcF,EAAkBJ,EAAUK,SAASvB,OAEnD,IAAIyB,EAAWf,GADfc,GAAcvC,EAAYe,QAGtByB,EAAWb,EAAUC,QAGrBD,EAAYM,GACFH,cAAgBA,EAC1BH,EAAUK,UAAYA,EACtBL,EAAUc,UAAY5B,EACtBc,EAAUE,MAAQA,EAClBF,EAAUC,KAAOY,KAK7B,IAAKb,EAAUC,KAEX,MAAO,CAAEJ,SAAU9B,KAAKsB,kBAAkBhB,EAAaG,IAK3DV,EAAOa,aAAeA,EAAe,EAErCb,EAAOO,YAAc2B,EAAUS,MAC/B,IAAIM,EAAehD,KAAKK,kBAAkBN,GAE1CA,EAAOO,YAAc2B,EAAUW,SAC/B,IAAIK,EAAkBjD,KAAKK,kBAAkBN,GAE7C,MAAO,CACHgD,UAAWd,EAAUc,UACrBT,UAAWL,EAAUK,UACrBF,cAAeH,EAAUG,cACzBD,MAAOF,EAAUE,MACjBO,MAAOM,EACPJ,SAAUK,EACVC,aAAcjB,EAAUS,MAAMrB,OAC9B8B,gBAAiBlB,EAAUW,SAASvB,UA1N/C,iCAiOG,SAAoB+B,EAAMvC,GAOtB,IANA,IACIY,IAKS,CAET,GAAI2B,EAAKtB,SAEL,OAAOsB,EAAKtB,SAIhBL,EAAQZ,EADDuC,EAAKL,WAQRK,GALJd,EAAYc,EAAKd,WAIHb,EAHN2B,EAAKjB,OAIFiB,EAAKV,MAELU,EAAKR,YAzP3B,mBAuQG,SAAM1B,EAAOC,EAAMmB,EAAWH,GAO1B,IANA,IAGItB,EAHA6B,EAAQ,GACRE,EAAW,GAKN3B,EAAIC,EAAMG,OAAS,EAAGJ,GAAK,EAAGA,IAI/BqB,GAHJzB,EAAOK,EAAMD,IACIE,GAEQgB,GACrBO,EAAMW,KAAKxC,GAEX+B,EAASS,KAAKxC,GAItB,MAAO,CACH6B,MAAOA,EACPE,SAAUA,KA3RrB,oBAgSG,WACI,OAAO5C,KAAKsD,WAAWtD,KAAKI,QAjSnC,wBAqSG,SAAWgD,GAEP,OAAIA,EAAKtB,SACE,CAAEyB,KAAMH,EAAKtB,UAGjB,CACHyB,KAAK,GAAD,OAAKH,EAAKL,UAAV,YAAuBK,EAAKhB,cAA5B,YAA6CgB,EAAKjB,MAAlD,MACJqB,SAAU,CACN,CACID,KAAM,MACNC,SAAU,CAACxD,KAAKsD,WAAWF,EAAKV,SAEpC,CACIa,KAAM,KACNC,SAAU,CAACxD,KAAKsD,WAAWF,EAAKR,kBApTnD,K,wBDwKca,MAnKf,WAEE,MAAsBC,mBAAS,IAA/B,mBAAOC,EAAP,KAAYC,EAAZ,KACA,EAA8BF,mBAAS,IAAvC,mBAAOG,EAAP,KAAgBC,EAAhB,KACA,EAA4BJ,mBAAS,IAArC,mBAAOK,EAAP,KAAeC,EAAf,KACA,EAA0CN,mBAAS,IAAnD,mBAAOO,EAAP,KAAsBC,EAAtB,KACA,EAAsCR,mBAAS,IAA/C,mBAAOS,EAAP,KAAoBC,EAApB,KACA,EAAgCV,oBAAS,GAAzC,mBAAOW,EAAP,KAAiBC,EAAjB,KACA,EAA4BZ,oBAAS,GAArC,mBAAOa,EAAP,KAAeC,EAAf,KACA,EAAkCd,mBAAS,IAA3C,mBAAOe,EAAP,KAAkBC,EAAlB,KAGMC,EAAU,CAAC,MAAO,aAAc,WAAY,aAAc,UAAW,kBAAmB,WAAY,WAAY,YAAa,QAAS,MAAO,OAAQ,UAAW,QAAS,YA+C/K,OAEE,sBAAKC,GAAG,OAAR,UACE,sBAAKC,UAAU,aAAf,UACE,4CACA,yDAEER,EAEG,GADH,8CAMDA,EAaU,qBAAKO,GAAG,OAAR,SAGNL,EAmBU,gCAEL,yDAEF,uBAAMO,SAzEC,SAACC,GACpBA,EAAEC,iBAEF,IAAIC,EAAS,CACXlB,SACAF,UACAF,OAGEuB,EAAmBrF,EAAasF,QAAQF,GAEpB,OAApBC,GAAiD,QAApBA,IAC/BA,EAAmB,UAGrBR,EAAaQ,IA0DD,UACE,uBAAOE,QAAQ,MAAf,iBACA,uBACA,uBAAOC,KAAK,OAAOT,GAAG,MAAMnD,MAAOkC,EAAK2B,SAAU,SAAAP,GAAC,OAAInB,EAAOmB,EAAEQ,OAAO9D,UACvE,uBAEA,uBAAO2D,QAAQ,UAAf,uBACA,uBACA,uBAAOC,KAAK,OAAOT,GAAG,UAAUnD,MAAOoC,EAASyB,SAAU,SAAAP,GAAC,OAAIjB,EAAWiB,EAAEQ,OAAO9D,UACnF,uBAEA,uBAAO2D,QAAQ,SAAf,oBACA,uBACA,uBAAOC,KAAK,OAAOT,GAAG,SAASnD,MAAOsC,EAAQuB,SAAU,SAAAP,GAAC,OAAIf,EAAUe,EAAEQ,OAAO9D,UAChF,uBAEA,uBAAO2D,QAAQ,gBAAf,iCACA,uBACA,uBAAOC,KAAK,iBAAiBT,GAAG,gBAAgBnD,MAAOwC,EAAeqB,SAAU,SAAAP,GAAC,OAAIb,EAAiBa,EAAEQ,OAAO9D,UAC/G,uBAEA,uBAAO2D,QAAQ,cAAf,gCACA,uBACA,uBAAOC,KAAK,iBAAiBT,GAAG,cAAcnD,MAAO0C,EAAamB,SAAU,SAAAP,GAAC,OAAIX,EAAeW,EAAEQ,OAAO9D,UACzG,uBAEA,wBAAQ4D,KAAK,SAAb,qCAGF,gDAAmBZ,QApDZ,oCAAM,uEACf,uBACEY,KAAK,OACLG,OAAO,kBACPF,SAAU,SAACP,GACT,IAAMU,EAAQV,EAAEQ,OAAOE,MACnBA,GACFC,IAAKC,MAAMF,EAAM,GAAI,CACnBG,UAAU,EACVC,QAAQ,EACRC,eAAe,EACfC,SAAU,SAAUC,IAtFrB,SAACC,GAClBA,EAAKC,MAAK,kBAAOtE,KAAKuE,SAAW,MAEjC,IAAIC,EAAYH,EAAKI,MAAM,EAAGzE,KAAK0E,MAAoB,GAAdL,EAAK5E,SAE9CxB,EAAe,IAAIC,EAAa,CAC9BS,kBAAmBoE,EACnBrE,YAAa8F,EACb3F,aAXkB,YAcpB+D,GAAU,GA4EU+B,CAAWP,EAAQC,iBA5BtB,gCACX,qFACA,sBAAKrB,GAAG,eAAR,UACE,cAAC,cAAD,CACE4B,SAAS,2EACTC,WAAW,+BACXC,UAnDW,SAAAC,GAEjBrC,GAAY,IAkDNsC,UA9CU,SAAAC,GACpBC,QAAQjF,IAAIgF,IA8CFE,aAAc,qBACdC,aAAa,OACbC,WAAW,UACXC,MAAM,kEATV,cExEKC,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCCdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,M","file":"static/js/main.86a3198e.chunk.js","sourcesContent":["import './App.css';\r\nimport { GoogleLogin } from 'react-google-login'\r\nimport axios from 'axios'\r\nimport { useState } from 'react';\r\nimport { DecisionTree } from \"./libraries/decisiontree.js\"\r\nimport Papa from \"papaparse\";\r\n\r\nlet decisionTree;\r\n\r\nfunction App() {\r\n\r\n  const [Vak, setVak] = useState('')\r\n  const [Klassen, setKlassen] = useState('')\r\n  const [Docent, setDocent] = useState('')\r\n  const [startDateTime, setStartDateTime] = useState('')\r\n  const [endDateTime, setEndDateTime] = useState('')\r\n  const [signedIn, setSignedIn] = useState(false)\r\n  const [upload, setUpload] = useState(false)\r\n  const [resultaat, setResultaat] = useState('');\r\n\r\n  const trainingLabel = \"Lokalen\"\r\n  const ignored = [\"Lnr\", \"Tijdberijk\", \"Lestekst\", \"Regeltekst\", \"Tijdvak\", \"Leerlingengroep\", \"Uurtekst\", \"lesweken\", \"ExternUur\", \"Datum\", \"Dag\", \"Uren\", \"Weekuur\", \"Begin\", \"Eindtijd\"]\r\n\r\n  const trainModel = (data) => {\r\n    data.sort(() => (Math.random() - 0.5))\r\n\r\n    let trainData = data.slice(0, Math.floor(data.length * 0.8))\r\n\r\n    decisionTree = new DecisionTree({\r\n      ignoredAttributes: ignored,\r\n      trainingSet: trainData,\r\n      categoryAttr: trainingLabel\r\n    })\r\n\r\n    setUpload(true);\r\n  }\r\n\r\n  const responseGoogle = response => {\r\n\r\n        setSignedIn(true)\r\n      \r\n  }\r\n\r\n  const responseError = error => {\r\n    console.log(error)\r\n  }\r\n\r\n\r\n  const handleSubmit = (e) => {\r\n    e.preventDefault()\r\n\r\n    let lokaal = {\r\n      Docent,\r\n      Klassen,\r\n      Vak,\r\n    }\r\n\r\n    let lokaalPrediction = decisionTree.predict(lokaal)\r\n\r\n    if (lokaalPrediction == \"NVT\" || lokaalPrediction == \"null\") {\r\n      lokaalPrediction = \"Online\"\r\n    }\r\n\r\n    setResultaat(lokaalPrediction)\r\n  \r\n  }\r\n\r\n\r\n  return (\r\n\r\n    <div id=\"body\">\r\n      <div className=\"App-header\">\r\n        <h1>Air Bender</h1>\r\n        <h2>Uw online roostermaker!</h2>\r\n\r\n        {!signedIn ? (\r\n          <div> Log in!</div>\r\n        ) : (\"\")}\r\n      </div>\r\n\r\n      {\r\n\r\n        !signedIn ? (<div>\r\n          <p>Log in via Google om een nieuw event in te plannen: </p>\r\n          <div id=\"GoogleButton\">\r\n            <GoogleLogin\r\n              clientId='982315485998-61qb28hgef1dmf709derbnb9nnunt0mu.apps.googleusercontent.com'\r\n              buttonText='Log in met uw Google account'\r\n              onSuccess={responseGoogle}\r\n              onFailure={responseError}\r\n              cookiePolicy={'single_host_origin'}\r\n              responseType='code'\r\n              accessType='offline'\r\n              scope='openid email profile https://www.googleapis.com/auth/calendar'\r\n            /> </div>\r\n        </div>) : (<div id=\"Form\">\r\n\r\n          {\r\n            !upload ? (<div> <h2>Upload een rooster bestand voor de AI</h2>\r\n              <input\r\n                type=\"file\"\r\n                accept=\".csv,.xlsx,.xls\"\r\n                onChange={(e) => {\r\n                  const files = e.target.files;\r\n                  if (files) {\r\n                    Papa.parse(files[0], {\r\n                      download: true,\r\n                      header: true,\r\n                      dynamicTyping: true,\r\n                      complete: function (results) {\r\n                        trainModel(results.data);\r\n                      }\r\n                    }\r\n                    )\r\n                  }\r\n                }}\r\n              />\r\n            </div>) : (<div>\r\n                  \r\n                  <h2>Plaats een reservering!</h2>\r\n\r\n                <form onSubmit={handleSubmit}>\r\n                  <label htmlFor='vak'>Vak</label>\r\n                  <br />\r\n                  <input type=\"text\" id=\"vak\" value={Vak} onChange={e => setVak(e.target.value)} />\r\n                  <br />\r\n  \r\n                  <label htmlFor='klassen'>Klas(sen)</label>\r\n                  <br />\r\n                  <input type=\"text\" id=\"klassen\" value={Klassen} onChange={e => setKlassen(e.target.value)} />\r\n                  <br />\r\n  \r\n                  <label htmlFor='docent'>Docent</label>\r\n                  <br />\r\n                  <input type=\"text\" id=\"docent\" value={Docent} onChange={e => setDocent(e.target.value)} />\r\n                  <br />\r\n  \r\n                  <label htmlFor='startDateTime'>Begin datum en tijd</label>\r\n                  <br />\r\n                  <input type=\"datetime-local\" id=\"startDateTime\" value={startDateTime} onChange={e => setStartDateTime(e.target.value)} />\r\n                  <br />\r\n  \r\n                  <label htmlFor='endDateTime'>Eind datum en tijd</label>\r\n                  <br />\r\n                  <input type=\"datetime-local\" id=\"endDateTime\" value={endDateTime} onChange={e => setEndDateTime(e.target.value)} />\r\n                  <br />\r\n  \r\n                  <button type=\"submit\">Voeg reservering toe</button>\r\n                </form>\r\n\r\n                <p>Het lokaal is: {resultaat}</p>\r\n\r\n              </div>)}\r\n\r\n              \r\n\r\n\r\n\r\n        </div>)\r\n      }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    </div>\r\n  );\r\n\r\n}\r\n\r\nexport default App;\r\n","/**\r\n * Creates an instance of DecisionTree\r\n * builder - contains training set and some configuration parameters\r\n */\r\n export class DecisionTree {\r\n    constructor(config) {\r\n        this.predicates = {\r\n            '==': function (a, b) { return a == b },\r\n            '>=': function (a, b) { return a >= b }\r\n        }\r\n        this.root = this.buildDecisionTree({\r\n            trainingSet: config.trainingSet,\r\n            ignoredAttributes: this.arrayToHashSet(config.ignoredAttributes),\r\n            categoryAttr: config.categoryAttr || 'category',\r\n            minItemsCount: config.minItemsCount || 1,\r\n            entropyThrehold: config.entropyThrehold || 0.01,\r\n            maxTreeDepth: config.maxTreeDepth || 70\r\n        })\r\n    }\r\n\r\n    // public predict\r\n    predict(item) {\r\n        return this.predictDecisionTree(this.root, item)\r\n    }\r\n\r\n    /**\r\n     * Transforming array to object with such attributes \r\n     * as elements of array (afterwards it can be used as HashSet)\r\n     */\r\n    arrayToHashSet(array) {\r\n        let hashSet = {}\r\n        if (array) {\r\n            for (let i in array) {\r\n                let attr = array[i]\r\n                hashSet[attr] = true\r\n            }\r\n        }\r\n        return hashSet\r\n    }\r\n\r\n    /**\r\n     * Calculating how many objects have the same  values of specific attribute.\r\n     * items - array of objects\r\n     * attr  - variable with name of attribute, which embedded in each object\r\n     */\r\n    countUniqueValues(items, attr) {\r\n        let counter = {}\r\n        // detecting different values of attribute\r\n        for (let i = items.length - 1; i >= 0; i--) {\r\n            // items[i][attr] - value of attribute\r\n            counter[items[i][attr]] = 0\r\n        }\r\n        // counting number of occurrences of each of values of attribute\r\n        for (let i = items.length - 1; i >= 0; i--) {\r\n            counter[items[i][attr]] += 1\r\n        }\r\n        return counter\r\n    }\r\n\r\n    /**\r\n     * Finding value of specific attribute which is most frequent in given array of objects.\r\n     * items - array of objects\r\n     * attr  - variable with name of attribute, which embedded in each object\r\n     */\r\n    mostFrequentValue(items, attr) {\r\n        // counting number of occurrences of each of values of attribute\r\n        let counter = this.countUniqueValues(items, attr);\r\n\r\n        let mostFrequentCount = 0;\r\n        let mostFrequentValue;\r\n\r\n        for (let value in counter) {\r\n            if (counter[value] > mostFrequentCount) {\r\n                mostFrequentCount = counter[value];\r\n                mostFrequentValue = value;\r\n            }\r\n        };\r\n\r\n        return mostFrequentValue;\r\n    }\r\n\r\n    /**\r\n     * Calculating entropy of array of objects by specific attribute.\r\n     * items - array of objects\r\n     * attr  - variable with name of attribute, which embedded in each object\r\n     */\r\n    entropy(items, attr) {\r\n        // counting number of occurrences of each of values of attribute\r\n        let counter = this.countUniqueValues(items, attr);\r\n\r\n        let entropy = 0;\r\n        let p;\r\n        for (let i in counter) {\r\n            p = counter[i] / items.length;\r\n            entropy += -p * Math.log(p);\r\n        }\r\n\r\n        return entropy;\r\n    }\r\n\r\n\r\n    /**\r\n     * Function for building decision tree\r\n     */\r\n    buildDecisionTree(config) {\r\n\r\n        let trainingSet = config.trainingSet\r\n        let minItemsCount = config.minItemsCount\r\n        let categoryAttr = config.categoryAttr\r\n        let entropyThrehold = config.entropyThrehold\r\n        let maxTreeDepth = config.maxTreeDepth\r\n        let ignoredAttributes = config.ignoredAttributes\r\n\r\n        if ((maxTreeDepth == 0) || (trainingSet.length <= minItemsCount)) {\r\n            // restriction by maximal depth of tree or size of training set is to small so we have to terminate process of building tree\r\n            return {\r\n                category: this.mostFrequentValue(trainingSet, categoryAttr)\r\n            };\r\n        }\r\n\r\n        let initialEntropy = this.entropy(trainingSet, categoryAttr)\r\n\r\n        if (initialEntropy <= entropyThrehold) {\r\n            // entropy of training set too small\r\n            // (it means that training set is almost homogeneous),\r\n            // so we have to terminate process of building tree\r\n            return {\r\n                category: this.mostFrequentValue(trainingSet, categoryAttr)\r\n            };\r\n        }\r\n\r\n        // used as hash-set for avoiding the checking of split by rules\r\n        // with the same 'attribute-predicate-pivot' more than once\r\n        let alreadyChecked = {};\r\n\r\n        // this variable expected to contain rule, which splits training set\r\n        // into subsets with smaller values of entropy (produces informational gain)\r\n        let bestSplit = { gain: 0 };\r\n\r\n        for (let i = trainingSet.length - 1; i >= 0; i--) {\r\n            let item = trainingSet[i];\r\n\r\n            // iterating over all attributes of item\r\n            for (let attr in item) {\r\n                if ((attr == categoryAttr) || ignoredAttributes[attr]) {\r\n                    continue;\r\n                }\r\n\r\n                // let the value of current attribute be the pivot\r\n                let pivot = item[attr];\r\n\r\n                // pick the predicate\r\n                // depending on the type of the attribute value\r\n                let predicateName;\r\n                if (typeof pivot == 'number') {\r\n                    predicateName = '>=';\r\n                } else {\r\n                    // there is no sense to compare non-numeric attributes\r\n                    // so we will check only equality of such attributes\r\n                    predicateName = '==';\r\n                }\r\n\r\n                let attrPredPivot = attr + predicateName + pivot;\r\n                if (alreadyChecked[attrPredPivot]) {\r\n                    // skip such pairs of 'attribute-predicate-pivot',\r\n                    // which been already checked\r\n                    continue;\r\n                }\r\n                alreadyChecked[attrPredPivot] = true;\r\n\r\n                let predicate = this.predicates[predicateName];\r\n\r\n                // splitting training set by given 'attribute-predicate-value'\r\n                let currSplit = this.split(trainingSet, attr, predicate, pivot);\r\n\r\n                // calculating entropy of subsets\r\n                let matchEntropy = this.entropy(currSplit.match, categoryAttr);\r\n                let notMatchEntropy = this.entropy(currSplit.notMatch, categoryAttr);\r\n\r\n                // calculating informational gain\r\n                let newEntropy = 0;\r\n                newEntropy += matchEntropy * currSplit.match.length;\r\n                newEntropy += notMatchEntropy * currSplit.notMatch.length;\r\n                newEntropy /= trainingSet.length;\r\n                let currGain = initialEntropy - newEntropy;\r\n\r\n                if (currGain > bestSplit.gain) {\r\n                    // remember pairs 'attribute-predicate-value'\r\n                    // which provides informational gain\r\n                    bestSplit = currSplit;\r\n                    bestSplit.predicateName = predicateName;\r\n                    bestSplit.predicate = predicate;\r\n                    bestSplit.attribute = attr;\r\n                    bestSplit.pivot = pivot;\r\n                    bestSplit.gain = currGain;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!bestSplit.gain) {\r\n            // can't find optimal split\r\n            return { category: this.mostFrequentValue(trainingSet, categoryAttr) };\r\n        }\r\n\r\n        // building subtrees\r\n\r\n        config.maxTreeDepth = maxTreeDepth - 1;\r\n\r\n        config.trainingSet = bestSplit.match;\r\n        let matchSubTree = this.buildDecisionTree(config);\r\n\r\n        config.trainingSet = bestSplit.notMatch;\r\n        let notMatchSubTree = this.buildDecisionTree(config);\r\n\r\n        return {\r\n            attribute: bestSplit.attribute,\r\n            predicate: bestSplit.predicate,\r\n            predicateName: bestSplit.predicateName,\r\n            pivot: bestSplit.pivot,\r\n            match: matchSubTree,\r\n            notMatch: notMatchSubTree,\r\n            matchedCount: bestSplit.match.length,\r\n            notMatchedCount: bestSplit.notMatch.length\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Classifying item, using decision tree\r\n     */\r\n    predictDecisionTree(tree, item) {\r\n        let attr,\r\n            value,\r\n            predicate,\r\n            pivot;\r\n\r\n        // Traversing tree from the root to leaf\r\n        while (true) {\r\n\r\n            if (tree.category) {\r\n                // only leafs contains predicted category\r\n                return tree.category;\r\n            }\r\n\r\n            attr = tree.attribute;\r\n            value = item[attr];\r\n\r\n            predicate = tree.predicate;\r\n            pivot = tree.pivot;\r\n\r\n            // move to one of subtrees\r\n            if (predicate(value, pivot)) {\r\n                tree = tree.match;\r\n            } else {\r\n                tree = tree.notMatch;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Splitting array of objects by value of specific attribute, using specific predicate and pivot.\r\n     * Items which matched by predicate will be copied to the new array called 'match', and the rest of the items \r\n     * will be copied to array with name 'notMatch'\r\n     * items - array of objects\r\n     * attr  - variable with name of attribute,which embedded in each object\r\n     * predicate - function(x, y) which returns 'true' or 'false'\r\n     * pivot - used as the second argument when calling predicate function:e.g. predicate(item[attr], pivot)\r\n     */\r\n    split(items, attr, predicate, pivot) {\r\n        let match = [];\r\n        let notMatch = [];\r\n\r\n        let item,\r\n            attrValue;\r\n\r\n        for (let i = items.length - 1; i >= 0; i--) {\r\n            item = items[i];\r\n            attrValue = item[attr];\r\n\r\n            if (predicate(attrValue, pivot)) {\r\n                match.push(item);\r\n            } else {\r\n                notMatch.push(item);\r\n            }\r\n        };\r\n\r\n        return {\r\n            match: match,\r\n            notMatch: notMatch\r\n        };\r\n    }\r\n\r\n    // return the trained model as json\r\n    toJSON() {\r\n        return this.treeToJson(this.root)\r\n    }\r\n    \r\n    // Recursive (DFS) function for displaying inner structure of decision tree\r\n    treeToJson(tree) {\r\n        // end leaf = prediction\r\n        if (tree.category) {\r\n            return { name: tree.category }\r\n        }\r\n\r\n        return {\r\n            name: `${tree.attribute} ${tree.predicateName} ${tree.pivot} ?`,\r\n            children: [\r\n                {\r\n                    name: \"yes\",\r\n                    children: [this.treeToJson(tree.match)]\r\n                },\r\n                {\r\n                    name: \"no\",\r\n                    children: [this.treeToJson(tree.notMatch)]\r\n                }\r\n            ]\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * Creates an instance of RandomForest with specific number of trees\r\n * builder - contains training set and some configuration parameters for building decision trees\r\n */\r\nexport class RandomForest {\r\n    constructor(config, treesNumber) {\r\n        this.trees = this.buildRandomForest(config, treesNumber)\r\n    }\r\n    predict(item) {\r\n        return this.predictRandomForest(this.trees, item)\r\n    }\r\n\r\n    /**\r\n     * Building array of decision trees\r\n     */\r\n    buildRandomForest(config, treesNumber) {\r\n        let items = config.trainingSet;\r\n\r\n        // creating training sets for each tree\r\n        let trainingSets = [];\r\n        for (let t = 0; t < treesNumber; t++) {\r\n            trainingSets[t] = [];\r\n        }\r\n        for (let i = items.length - 1; i >= 0; i--) {\r\n            // assigning items to training sets of each tree\r\n            // using 'round-robin' strategy\r\n            let correspondingTree = i % treesNumber;\r\n            trainingSets[correspondingTree].push(items[i]);\r\n        }\r\n\r\n        // building decision trees\r\n        let forest = [];\r\n        for (let t = 0; t < treesNumber; t++) {\r\n            config.trainingSet = trainingSets[t];\r\n\r\n            let tree = new DecisionTree(config);\r\n            forest.push(tree);\r\n        }\r\n        return forest;\r\n    }\r\n\r\n    /**\r\n     * Each of decision tree classifying item\r\n     * ('voting' that item corresponds to some class).\r\n     *\r\n     * This function returns hash, which contains \r\n     * all classifying results, and number of votes \r\n     * which were given for each of classifying results\r\n     */\r\n    predictRandomForest(forest, item) {\r\n        let result = {};\r\n        for (let i in forest) {\r\n            let tree = forest[i];\r\n            let prediction = tree.predict(item);\r\n            result[prediction] = result[prediction] ? result[prediction] + 1 : 1;\r\n        }\r\n        return result;\r\n    }\r\n}","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\n\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}